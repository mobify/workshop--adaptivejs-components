/**
 * AMD implementation for dust.js
 * This is based on require-cs code.
 * see: http://github.com/jrburke/require-cs for details
 */

/* global define, window, XMLHttpRequest, importScripts, Packages, java,
 ActiveXObject, process, require */

// JB MOD: Change to `dust-core`.

define(['dust-full', 'component-handler'], function(dust, componentHandler) {
    'use strict';

    var componentsEnabled = componentHandler.isEnabled();

    if (componentsEnabled) {
        var installedComponents = componentHandler.getInstalledComponents();
        var componentLocations = componentHandler.getLocations();
    }

    // Disable whitespace stripping
    if (dust.optimizers) {
        dust.optimizers.format = function(ctx, node) {
            return node;
        };
    }

    // Below is necessary for dynamic require when running tests in a generated
    // Adaptive.js project
    var fs, getXhr,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        fetchText = function() {
            throw new Error('Environment unsupported.');
        },
        buildMap = {};

    if (typeof process !== 'undefined' &&
        process.versions && !!process.versions.node) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');
        fetchText = function(path, callback) {
            callback(fs.readFileSync(path, 'utf8'));
        };
    } else if ((typeof window !== 'undefined' && window.navigator && window.document) || typeof importScripts !== 'undefined') {
        // Browser action
        getXhr = function() {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== 'undefined') {
                return new XMLHttpRequest();
            } else {
                for (i = 0; i < 3; i++) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {
                    }

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            if (!xhr) {
                throw new Error('getXhr(): XMLHttpRequest not available');
            }

            return xhr;
        };

        fetchText = function(url, callback) {
            var xhr = getXhr();
            xhr.open('GET', url, true);
            xhr.onreadystatechange = function(evt) {
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    callback(xhr.responseText);
                }
            };
            xhr.send(null);
        };
        // end browser.js adapters
    }

    return {
        write: function(pluginName, name, write) {
            if (buildMap.hasOwnProperty(name)) {
                var text = buildMap[name];
                write.asModule(pluginName + '!' + name, text);
            }
        },

        load: function(name, parentRequire, load, config) {
            var path = parentRequire.toUrl(name + '.dust');

            fetchText(path, function(text) {
                // Get Dependencies.
                // Sadly, the dust compiler doesn't give us good information
                // about the dependencies of the template.
                var deps = ['dust-custom'];

                // Partial Syntax:
                // {>"templates/project/_results-text"/}
                var partialRe = /\{>"([\w\/-]+)"[^\/]*\/\}/gi;

                var partialMatch;
                while ((partialMatch = partialRe.exec(text)) !== null) {
                    deps.push('dust!' + partialMatch[1]);
                }

                if (componentsEnabled) {
                    // Component Syntax:
                    // {@c-name [params] /} or
                    // {@c-name [params]}{/c-name}
                    var componentRe = /\{@c-([\w-]+).*\/?\}/gi;
                    var componentMatch, templateName, componentName, componentPath;

                    while ((componentMatch = componentRe.exec(text)) !== null) {
                        componentName = templateName = componentMatch[1];

                        if (templateName.indexOf('__') !== -1) {
                            componentName = templateName.split('__')[0];
                        }

                        if (installedComponents[templateName] === 'stencil') {
                            componentPath = componentLocations.stencil + '/stencil-';
                        } else {
                            componentPath = componentLocations.local + '/';
                        }

                        deps.push('dust!' + componentPath + componentName + '/' + templateName);
                    }
                }

                var depString = JSON.stringify(deps);

                // Create dust template
                try {
                    text = 'define(' + depString + ',function(dust){' + dust.compile(text, name, false) + ' return function(context, callback) {return dust.render("' + name + '", context, callback)}})';
                }
                catch (err) {
                    err.message = 'In ' + path + ', ' + err.message;
                    throw(err);
                }

                // Hold on to the transformed text if a build.
                if (config.isBuild) {
                    buildMap[name] = text;
                }

                //IE with conditional comments on cannot handle the
                //sourceURL trick, so skip it if enabled.
                /*@if (@_jscript) @else @*/
                if (!config.isBuild) {
                    text += '\r\n//@ sourceURL=' + path;
                }
                /*@end@*/

                load.fromText(name, text);

                parentRequire([name], function(value) {
                    load(value);
                });
            });
        }
    };
});
