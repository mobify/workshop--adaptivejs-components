/*jshint maxstatements: false */

define([
    'dust-core',
    'adaptivejs/utils',
    'dust-component-helper',
    'dust-component-sugar',
    'component-handler'
], function(
    dust,
    Utils,
    componentHelper,
    componentSugar,
    componentHandler
) {
    /**
     * Add the core component helper to dust.helpers.
     */
    dust = componentHelper(dust);

    var likeArray = function(candidate) {
        return (typeof candidate !== 'string') && (typeof candidate.length === 'number') && (!candidate.tagName);
    };

    var nodeName = function(node) {
        return node.nodeName.toLowerCase();
    };

    var escapeQuote = function(s) {
        return s.replace('"', '&quot;');
    };

    /**
     * Determines if the supplied node is a Node type, or a Node type of the node's window.
     */
    var isNode = function(node) {
        return node instanceof Node ||
                node && node.ownerDocument && node.ownerDocument.defaultView && (node instanceof node.ownerDocument.defaultView.Node);
    };

    /**
     * Registers an individual helper for each component template that has been
     * loaded. This provides syntactic sugar for using components in views,
     * especially the ability to use the component name in the closing tag.
     */
    if (componentHandler.isEnabled()) {
        var installedComponents = componentHandler.getInstalledComponents();
        var componentLocations = componentHandler.getLocations();

        for (var templateName in installedComponents) {
            if (installedComponents.hasOwnProperty(templateName)) {
                var componentPath;
                var componentName = templateName.split('__')[0];
                var helperName = componentSugar.normalizeName(templateName);

                // Determine if component is an installed stencil, or a
                // local creation
                if (installedComponents[templateName] === 'stencil') {
                    componentPath = componentLocations.stencil + '/stencil-';
                } else {
                    componentPath = componentLocations.local + '/';
                }

                componentPath = componentPath + componentName + '/' + templateName;

                dust.helpers[helperName] = componentSugar.makeHelper(componentPath);
            }
        }
    }

    var oldIsArray = dust.isArray;
    dust.isArray = function(arr) {
        return Boolean(arr && arr.appendTo) || oldIsArray(arr);
    };

    /**
     *  Return a string for the opening tag of DOMElement `element`.
     */
    dust.filters.openTag = function(element) {
        if (!element) {
            return '';
        }
        if (element.length) {
            element = element[0];
        }

        var stringBuffer = [];

        [].forEach.call(element.attributes, function(attr) {
            stringBuffer.push(' ', attr.name, '="', escapeQuote(attr.value), '"');
        });
        return '<' + nodeName(element) + stringBuffer.join('') + '>';
    };

    /**
     *  Return a string for the closing tag of DOMElement `element`.
     */
    dust.filters.closeTag = function(element) {
        if (!element) {
            return '';
        }
        if (element.length) {
            element = element[0];
        }

        return '</' + nodeName(element) + '>';
    };

    /**
     *  Override the behaviour of the default dust.js filter when
     *  using {key}.
     */
    dust.filters.h = function(node) {
        if (!node) {
            return '';
        }

        // Check if the node is a TextNode
        if (node.nodeType === 3) {
            if (node.nodeValue) {
                return node.nodeValue;
            }
        }

        if (isNode(node)) {
            return Utils.outerHTML(node);
        }

        if (likeArray(node)) {
            var result = [];
            for (var i = 0, len = node.length; i < len; i++) {
                result.push(dust.filters.h(node[i]));
            }
            return result.join('');
        }

        return dust.escapeHtml(node);
    };

    dust.filters.innerHTML = function(node) {
        if (!node) {
            return '';
        }
        if (likeArray(node)) {
            var result = [];
            for (var i = 0, len = node.length; i < len; i++) {
                result.push(node[i].innerHTML || node[i].nodeValue);
            }
            return result.join('');
        }
        else {
            return node.innerHTML;
        }
    };

    // Adds 'count' helper. Like idx, but this one goes to 11. It's 1 higher.
    dust.helpers.count = function(chunk, context, bodies) {
        return bodies.block(chunk, context.push(context.stack.index + 1));
    };

    /**
     *  Returns a full url for an asset including a cache breaker
     */
    dust.helpers.getUrl = function(chunk, context, bodies, params) {
        var url = Utils.getAssetUrl(params.path, params.baseUrl, params.cacheBreaker);
        return chunk.write(url);
    };

    // Override methods in Context and Chunk in order to get chain inheritance,
    // as well as for adding _SUPER_
    var Context = dust.makeBase({}).constructor;
    var Chunk = dust.stream('', {}).head.constructor;

    var oldBlock = Chunk.prototype.block;
    Chunk.prototype.block = function(elem, context, bodies) {
        var topElem = elem ? elem.shift() : undefined;
        if (topElem) {
            context.global = context.global || {};
            // Add `_SUPER_` to the block context.
            context.global._SUPER_ = function(_elem, context, _bodies) {
                return _elem.block(elem, context, bodies);
            };
            context = new context.constructor(context.stack, context.global, context.blocks);
        }

        return oldBlock.call(this, topElem, context, bodies);
    };

    Context.prototype.getBlock = function(key, chk, ctx) {
        if (typeof key === 'function') {
            var tempChk = new Chunk();
            key = key(tempChk, this).data.join('');
        }

        var blocks = this.blocks;

        if (!blocks) {
            dust.log('No blocks for context[{' + key + '}] in template [' + this.getTemplateName() + ']', 'DEBUG');
            return;
        }
        var newBlocks = [];
        for (var i = 0, len = blocks.length; i < len; i++) {
            // Only push the block if it's not undefined
            blocks[i][key] && newBlocks.push(blocks[i][key]);
        }
        return newBlocks;
    };

    return dust;
});
