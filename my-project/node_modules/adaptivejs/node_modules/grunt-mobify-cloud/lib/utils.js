var grunt = require('grunt');
var fs = require('fs');
var path = require('path');
var archiver = require('archiver');
var Request = require('request');
var gruntMobifyVersion = require('../package.json')['version'];

exports.createBundle = function(filePaths, projectSlug, destination, cb) {
    var output = fs.createWriteStream(destination);
    var archive = archiver('tar');

    archive.on('error', function(err) {
        throw err;
    });

    archive.pipe(output);

    filePaths.forEach(function(srcPath) {
        // Ignore directories.
        if (!grunt.file.isFile(srcPath)) {
            return;
        }

        // Cloud expects files in a bundle to live under `/project-slug/bld/'.

        // Strip leading directory, e.g. 'build/'.
        destPath = srcPath.replace(/[^\/]+\//, '');

        // And replace it with 'project-slug/bld/'.
        destPath = path.join(projectSlug, 'bld', destPath);

        archive.file(srcPath, { name: destPath });
    });

    archive.finalize();
    output.on('finish', cb);
};

exports.readCredentials = function(filepath) {
    // Read credentials
    if (!grunt.file.exists(filepath)) {
        grunt.fail.warn('Settings file "' + filepath + '" not found.');
        return false;
    }

    var creds = grunt.file.readJSON(filepath);

    return creds.username + ':' + creds.api_key;
};

exports.buildObject = function(filepath, message){
    // encoding: null ensures that a Buffer is returned
    var data = grunt.file.read(filepath, {encoding: null});

    // Encode data and assemble object to upload
    var base64data = data.toString('base64');

    var buildObj = {
        message: message || '',
        encoding: "base64",
        data: base64data
    };

    return buildObj;
};

exports.getSettingsPath = function() {
    if (process.platform === 'win32'){
        return process.env.USERPROFILE + '/.mobify';
    }
    return process.env.HOME + '/.mobify';
};


/**
 * Request helpers
 */

var stripLeadingAndTrailingSlashes = function(str) {
    return str.replace(/^\/|\/$/g, '');
};

// Join all segments and end with a slash
var urlJoin = function(segments) {
    var isEmpty = function(x) { return !!x; }
    return segments.filter(isEmpty).join('/') + '/';
};

exports.getProjectApiPath = function(origin, slug, path, target) {
    target = target || '';

    origin = stripLeadingAndTrailingSlashes(origin);
    path = stripLeadingAndTrailingSlashes(path);
    target = stripLeadingAndTrailingSlashes(target);

    return urlJoin([
        origin,
        'api/projects',
        slug,
        path,
        target
    ]);
};

exports.getRequestHeaders = function(additionalHeaders) {
    var headers = {
        'User-Agent': 'grunt-mobify#' + gruntMobifyVersion
    };

    // Merge `additionalHeaders` into `headers`.
    if (additionalHeaders) {
        for (header in additionalHeaders) {
            headers[header] = additionalHeaders[header];
        }
    }

    return headers;
};

var throwForStatus = exports.throwForStatus = function(response) {
    var msg = null;
    var status = response.statusCode;

    if (status >= 400) {
        if (status >= 500) {
            msg = "Got a bad response: " + response.body;
        }
        else {
            var body = JSON.parse(response.body);
            var msg = body["message"];
            var docs_url = body["docs_url"];

            // Checks in case there are docs available for the issue. Requires the error
            // message to be in JSON format
            if (docs_url !== undefined && docs_url !== '') {
                msg = msg + "\nVisit this link for more information: " + docs_url.bold.black;
            }
        }
        throw new Error(msg);
    }
};

exports.buildRequest = function(options, cb) {
    // Avoids DEPTH_ZERO_SELF_SIGNED_CERT error for self-signed certs
    process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";

    var headers = this.getRequestHeaders();

    var uri = this.getProjectApiPath(
        options.origin, options.projectSlug, 'builds', options.target
    );
    var headers = this.getRequestHeaders(
        {'Content-Length': options.dataLength}
    );

    var opts = {
        uri: uri,
        method: 'POST',
        auth: options.auth,
        headers: headers
    };

    var request = new Request(opts, function(err, response, body) {
        if (err){
            throw new Error("Failed to upload build: " + err);
        }
        throwForStatus(response);

        previewUrl = JSON.parse(body)["bundle_preview_url"];

        console.log("Build uploaded!");
        grunt.log.subhead("Link to preview the bundle: " + previewUrl);
        cb();
    });

    return request;
};
