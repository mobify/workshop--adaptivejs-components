/*jshint forin: false */

define([
    'adaptivejs/context',
    'adaptivejs/logger',
    'adaptivejs/utils'
], function(Context, Logger, Utils) {

    var View = {};

    /**
     *  Executes the passed function, but wraps in a try/catch.
     */
    var safeExecFunction = function(func, errPrefix, params) {
        errPrefix = errPrefix || '';
        params = params || [];
        try {
            func.apply(this, params);
        } catch (e) {
            console.error(errPrefix, e.stack);
        }
    };

    /**
     *  Adds any context from partials to the views context.
     *  Tack on include preProcess methods to the list of methods to run.
     */
    var processIncludes = function(includes, includeMethods, context) {
        // tmp array to preserve preProcess execution order
        var preTemp = [];
        var postTemp = [];
        var tempContext = {};
        for (var key in includes){
            // Don't add include if a child already added it
            if (!includes.hasOwnProperty(key) || context.hasOwnProperty(key)) {
                continue;
            }

            var include = includes[key];

            // Add includes to tempContext which we extend to preserve order
            tempContext[key] = include.context;
            include.preProcess && preTemp.push({'key': key, 'function': include.preProcess});
            include.postProcess && postTemp.push({'key': key, 'function': include.postProcess});
        }

        // Add preProcess methods to the start of the list so they run in order
        includeMethods.preProcess = preTemp.concat(includeMethods.preProcess);
        includeMethods.postProcess = postTemp.concat(includeMethods.postProcess);

        // Add includes to the context
        return Utils.extend(tempContext, context);
    };

    /**
     *  Evaluates and returns a views context by:
     *  1. Extend context of all includes onto the view
     *  2. Extend context of any parent views onto the context
     *  3. Call preProcess method of all includes which define it
     *  4. Call parent views proProcess, unless the child view overrides it
     *  5. Evaluating all the context keys
     *  6. Call postProcess method of all includes which define it
     *  7. Call parent views postProcess, unless the view overrides it
     */
    /* jshint ignore:start */
    View.evaluateContext = function(view, defaultContext) {
        // Used to store preProcess functions for later execution
        var includeMethods = {
            preProcess: [],
            postProcess: []
        };
        var includes = {};
        var error;
        var i;

        // Build up view
        var tempContext = this.compileContext(view, defaultContext, includes, includeMethods);

        // Call all include preProcess functions in correct order
        for (i = 0; i < includeMethods.preProcess.length; i++) {
            var preProcess = includeMethods.preProcess[i];
            error = 'Error calling preProcess from' + preProcess.key;

            tempContext = safeExecFunction(preProcess['function'], error, [tempContext]) || tempContext;
            Logger.addTimingPoint(preProcess.key + 'PreProcess', {namespace: 'Evaluating View'});
        }

        // Call preProcess from the view, or it's closest ancestor
        var viewPreProcess = getClosestProperty(view, 'preProcess');
        if (viewPreProcess) {
            tempContext = safeExecFunction(viewPreProcess, 'Error calling views preProcess', [tempContext]) || tempContext;
            Logger.addTimingPoint('viewPreProcess', {namespace: 'Evaluating View'});
        }

        // Evaluate context
        tempContext = Context.process(tempContext);

        // Call all include postProcess functions
        for (i = 0; i < includeMethods.postProcess.length; i++) {
            var postProcess = includeMethods.postProcess[i];
            error = 'Error calling postProcess from' + postProcess.key;

            tempContext = safeExecFunction(postProcess['function'], error, [tempContext]) || tempContext;
            Logger.addTimingPoint(postProcess.key + 'PostProcess', {namespace: 'Evaluating View'});
        }

        // Call postProcess from the view, or it's closest ancestor
        var viewPostProcess = getClosestProperty(view, 'postProcess');
        if (viewPostProcess){
            tempContext = safeExecFunction(viewPostProcess, 'Error calling views postProcess', [tempContext]) || tempContext;
            Logger.addTimingPoint('viewPostProcess', {namespace: 'Evaluating View'});
        }

        Logger.addTimingPoint('View processed');
        Logger.logCollapsed('Evaluated Context', tempContext);
        return tempContext;
    };
    /* jshint ignore:end */

    /**
     *  Builds up the structure of the views context, inherriting from parents
     *  Doesn't evaluate any functions.
     */
    View.compileContext = function(view, context, includes, includeMethods) {
        var parentView = view.extend;

        // We use this to build the context in the correct order
        var tempContext = context || {};

        // Add all includes to the context
        if (view.includes) {
            tempContext = processIncludes(view.includes, includeMethods, tempContext);
        }

        // If there is a parent view, extend it.
        if (parentView) {
            // Remove keys that will be overridden to preserve order
            for (var key in parentView.context) {
                if (view.context.hasOwnProperty(key)) {
                    delete parentView.context[key];
                }
            }

            tempContext = View.compileContext(view.extend, tempContext, includes, includeMethods);
        }

        // Add the views context after all the previous context keys
        // for proper evaluation order
        tempContext = Utils.extend(tempContext, view.context);

        return tempContext;

    };

    /**
     *  Finds the closest ancestor to the view with the given property.
     *  Returns that property.
     */
    var getClosestProperty = function(view, property) {
        if (!view.extend && !view[property]){
            return undefined;
        }
        return view[property] || getClosestProperty(view.extend, property);
    };

    return View;

});
