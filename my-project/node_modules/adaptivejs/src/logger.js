define([
    'adaptivejs/utils'
], function(Utils) {

    var Logger = {};
    var TIMING_POINTS = Logger.TIMING_POINTS = 'adaptiveTimingPoints';

    /**
     *  Lets guard our calls to set item for two possible failure
     *  scenarios
     *    1) The device does not supportLocalStorage
     *    2) Local storage is full
     */
    var setItem = function(item, value) {
        if (!Utils.supportsLocalStorage()) {
            return;
        }
        try {
            return localStorage.setItem(item, value);
        } catch (e) {
            return;
        }
    };

    /**
     *  Setup the logger and initialize the start time
     *  Takes a debug argument and a start time,
     *  both of which are optional.
     */
    Logger.init = function(options) {
        options = options || {};
        this.points = {};
        var debug = options.debug !== undefined ? options.debug : false;
        var start = options.start || +new Date();

        // Make sure we aren't using any old logging points
        this.clearData();

        // Persist the debugger
        this.setDebugger(debug);

        // Tracks depth of recursion for output indentation
        Logger.stackDepth = 1;

        // Add the first timing point
        this.addTimingPoint('Start', {value: start});
    };

    /**
     *  Formats a name and data point into a nice logger entry
     */
    Logger.formatDataPoint = function(name, point) {
        var points = this.points || this.getJSONFromLocalStorage(TIMING_POINTS);
        var start = points.Start || 0;
        var diff = point - start;
        return name + ': ' + diff + 'ms';
    };

    /**
     *  Increase value of stack depth tracker
     */
    Logger.increaseStack = function() {
        this.stackDepth += 1;
    };

    /**
     *  Decrease value of stack depth tracker
     */
    Logger.decreaseStack = function() {
        this.stackDepth -= 1;
    };

    /**
     *  Remove logging data from local storage
     */
    Logger.clearData = function() {
        localStorage.removeItem(TIMING_POINTS);
    };

    /**
     *  Resets the debugger if you need to do it at a later state
     */
    Logger.setDebugger = function(debug) {
        this.debugMode = debug;
        setItem('debug', debug);
    };

    /**
     *  Uses the console to log the give message if debugMode is true
     *  Takes an optional logLevel argument to log errors or warnings
     */
    Logger.log = function(message, logLevel) {
        if (!this.debugMode) {
            return;
        }

        logLevel = logLevel || 'log';
        try {
            console[logLevel](message);
        } catch (e) {
            console.log(message);
        }
    };

    /**
     *  Adds a data point to timing point group.
     *
     *  `key` is required.
     *  `options.value` is optional
     *   (if not given, the current timestamp will be added)
     *  `options.namespace` is optional
     *   (if not given, will log key to top level points object)
     */
    Logger.addTimingPoint = function(key, options) {
        if (!this.debugMode) {
            return;
        }

        options = options || {};

        // Indent key based on it's stack depth
        // SJ TODO: There is an issue where stackDepth can be undefined when
        // using the Logger post-document.write. This needs to be addressed!
        key = new Array(this.stackDepth || 1).join('\t') + key;

        // In non-Webkit based browsers, the `points` object will get blown away due
        // to our use of `document.open`, thus if `points` is undefined, we will get
        // the logging information from localStorage.
        var points = this.points || this.getJSONFromLocalStorage(TIMING_POINTS) || {};
        var value = options.value || +new Date();
        var namespace = options.namespace;

        if (namespace) {
            points[namespace] = points[namespace] || {};
            points[namespace][key] = value;
        } else {
            points[key] = value;
        }
        this.saveJSONToLocalStorage(TIMING_POINTS, points);
    };

    /**
     * Deprecated function. Kept around for backwards compatibility.
     */
    Logger.addPoint = function(localStorageKey, key, options) {
        Logger.addTimingPoint(key, options);
    };

    /**
     *  Stringifies a JSON object then saves it to local storage
     */
    Logger.saveJSONToLocalStorage = function(name, collection) {
        setItem(name, JSON.stringify(collection));
    };

    /**
     *  Retrieves a JSON string from local storage and parses it into an object
     */
    Logger.getJSONFromLocalStorage = function(name) {
        if (!Utils.supportsLocalStorage()) {
            return;
        }
        try {
            var jsonData = localStorage.getItem(name);
            if (jsonData === null) {
                return null;
            }
            return JSON.parse(jsonData);
        } catch (e) {
            console.error('Error getting data from local storage:\n' + e);
            return;
        }
    };

    /**
     *  Formats a logGroup if supported
     */
    Logger.logGroup = function(group, name) {
        if (!this.debugMode) {
            return;
        }
        console.groupCollapsed ? console.groupCollapsed(name) : console.group(name);

        for (var key in group) {
            if (group.hasOwnProperty(key)) {
                // If the value is a string, parse it to JSON
                if (Object.prototype.toString.call(group[key]) === '[object Object]') {
                    this.logGroup(group[key], key);
                }
                else {
                    console.log(Logger.formatDataPoint(key, group[key]));
                }
            }
        }
        console.groupEnd();
    };

    /**
     *  Logs the content in a collapsed group
     */
    Logger.logCollapsed = function(groupName, content) {
        if (!this.debugMode) {
            return;
        }
        console.groupCollapsed ? console.groupCollapsed(groupName) : console.group(groupName);

        console.log(content);
        console.groupEnd();
    };

    /**
     *  Adds the DOMContentLoaded event to the data points object
     *  Name is optional
     */
    Logger.addDOMContentListener = function() {
        var self = this;
        document.addEventListener('DOMContentLoaded', function() {
            self.addTimingPoint('DOMContentLoaded');
        }, false);
    };

    /**
     *  Adds both document and window listeners as some browsers prefer one over
     *  the other. This is the same way jQuery handles this. Adds the point on
     *  which is fired first.
     */
    Logger.addOnLoadListener = function(callback) {
        var self = this;

        var addPageLoadPointCallback = function() {
            if (!this.pageLoaded) {
                this.pageLoaded = +new Date();
                self.addTimingPoint('Page Load', +new Date());
                callback && callback();
            }
        };

        document.addEventListener('load', addPageLoadPointCallback, false);
        window.addEventListener('load', addPageLoadPointCallback, false);
    };

    Logger.logTimingPoints = function() {
        var points = this.points || this.getJSONFromLocalStorage(TIMING_POINTS);
        this.logGroup(points, 'Timing Points');
    };

    return Logger;
});
